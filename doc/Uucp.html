<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Uucp" rel="Chapter" href="Uucp.html"><link title="Unicode version" rel="Section" href="#version">
<link title="Characters" rel="Section" href="#uchar">
<link title="Properties" rel="Section" href="#props">
<link title="Property module distribution and omissions" rel="Section" href="#distrib_omit">
<link title="Property module distribution and omissions" rel="Section" href="#distrib_omit">
<link title="Minimal Unicode introduction" rel="Section" href="#uminimal">
<link title="Property module distribution and omissions" rel="Section" href="#distrib_omit">
<link title="Minimal Unicode introduction" rel="Section" href="#uminimal">
<link title="Characters — if they exist" rel="Subsection" href="#characters">
<link title="Interlude — what is assigned ?" rel="Subsection" href="#assignements">
<link title="Serializing integers — UTF-X" rel="Subsection" href="#serializing">
<link title="Interlude — Useful scalar values" rel="Subsection" href="#2_InterludeUsefulscalarvalues">
<link title="Equivalence and normalization" rel="Subsection" href="#equivalence">
<link title="Collation — sorting in alphabetical order" rel="Subsection" href="#collation">
<link title="Biased tips for OCaml programs and libraries" rel="Subsection" href="#tips">
<link title="Characters — if they exist" rel="Subsection" href="#characters">
<link title="Interlude — what is assigned ?" rel="Subsection" href="#assignements">
<link title="Serializing integers — UTF-X" rel="Subsection" href="#serializing">
<link title="Interlude — Useful scalar values" rel="Subsection" href="#2_InterludeUsefulscalarvalues">
<link title="Equivalence and normalization" rel="Subsection" href="#equivalence">
<link title="Collation — sorting in alphabetical order" rel="Subsection" href="#collation">
<link title="Biased tips for OCaml programs and libraries" rel="Subsection" href="#tips">
<title>Uucp</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Uucp.html">Uucp</a></h1>

<pre><span class="keyword">module</span> Uucp: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Unicode character properties.
<p>

    <code class="code"><span class="constructor">Uucp</span></code> provides efficient access to a selection of character
    <a href="Uucp.html#props">properties</a> of the Unicode character database.
<p>

    Consult the individual modules for sample code related to the
    properties. A <a href="Uucp.html#uminimal">minimal Unicode introduction</a> is also
    available.
<p>

    <em>Release 1.1.0 — Unicode version 8.0.0 —
    Daniel Bünzli &lt;daniel.buenzl i@erratique.ch&gt; </em>
<p>

    <h3 id="3_References">References</h3>
    <ul>
<li><a href="http://www.unicode.org/faq/">The Unicode FAQ.</a></li>
<li>The Unicode Consortium.
    <em><a href="http://www.unicode.org/versions/latest">The Unicode Standard</a></em>.
    (latest version)</li>
<li>Mark Davis, Ken Whistler.
    <em><a href="http://www.unicode.org/reports/tr44/">UAX #44 Unicode Character
    Database</a></em>. (latest version)</li>
</ul>
<br>
</div>
<hr width="100%">
<br>
<h1 id="version">Unicode version</h1><br>

<pre><span id="VALunicode_version"><span class="keyword">val</span> unicode_version</span> : <code class="type">string</code></pre><div class="info ">
<code class="code">unicode_version</code> is the Unicode version supported by the library.<br>
</div>
<br>
<h1 id="uchar">Characters</h1><br>

<pre><span id="TYPEuchar"><span class="keyword">type</span> <code class="type"></code>uchar</span> = <code class="type">int</code> </pre>
<div class="info ">
The type for Unicode characters. A value of this type <b>must</b>
    be an Unicode
      <a href="http://unicode.org/glossary/#unicode_scalar_value"> scalar
      value</a> which is an integer in the ranges <code class="code">0x0000</code>…<code class="code">0xD7FF</code>
      and <code class="code">0xE000</code>…<code class="code">0x10FFFF</code>. This can be asserted
    with <a href="Uucp.Uchar.html#VALis_uchar"><code class="code"><span class="constructor">Uucp</span>.<span class="constructor">Uchar</span>.is_uchar</code></a>.<br>
</div>


<pre><span class="keyword">module</span> <a href="Uucp.Uchar.html">Uchar</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Uchar.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Characters.
</div>
<br>
<h1 id="props">Properties</h1>
<p>

    Consult information about the <a href="Uucp.html#distrib_omit">property distribution
    in modules and omissions</a>.
<p>

    <b>Warning.</b> The result of functions is undefined if their <code class="code">uchar</code>
    arguments do not satisfy the <a href="Uucp.Uchar.html#VALis_uchar"><code class="code"><span class="constructor">Uucp</span>.<span class="constructor">Uchar</span>.is_uchar</code></a> predicate.<br>

<pre><span class="keyword">module</span> <a href="Uucp.Age.html">Age</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Age.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Age property.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Alpha.html">Alpha</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Alpha.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Alphabetic property.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Block.html">Block</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Block.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Block property and block ranges.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Break.html">Break</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Break.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Break properties.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Case.html">Case</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Case.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Case properties, mappings and foldings.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Cjk.html">Cjk</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Cjk.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
CJK properties.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Func.html">Func</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Func.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Function and graphics properties.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Gc.html">Gc</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Gc.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
General category property.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Gen.html">Gen</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Gen.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
General properties.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Id.html">Id</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Id.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Identifier properties.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Name.html">Name</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Name.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Name and name alias properties.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Num.html">Num</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Num.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Numeric properties.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.Script.html">Script</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.Script.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Script and script extensions properties.
</div>

<pre><span class="keyword">module</span> <a href="Uucp.White.html">White</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Uucp.White.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
White space property.
</div>
<br>
<h1 id="distrib_omit">Property module distribution and omissions</h1>
<p>

    Properties are approximatively distributed in modules by scope of use
    like in this
    <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">property
    index table</a>. However some subset of properties
    live in their own modules.
<p>

    Obsolete and
    <a href="http://www.unicode.org/reports/tr44/#Deprecated_Property_Table">
    deprecated</a> properties are
    omitted.  So are those related to normalization, shaping and
    bidirectionality. Here is the full list of omitted properties,
    if you think one of these property should be added get in touch
    with a rationale.
    <ul>
<li>General properties.
       <a href="http://www.unicode.org/reports/tr44/#Hangul_Syllable_Type">
       Hangul_Syllable_Type</a>.</li>
<li>Case.
       <a href="http://www.unicode.org/reports/tr44/#Simple_Lowercase_Mapping">
       Simple_Lowercase_Mapping</a>,
       <a href="http://www.unicode.org/reports/tr44/#Simple_Uppercase_Mapping">
       Simple_Uppercase_Mapping</a>,
       <a href="http://www.unicode.org/reports/tr44/#Simple_Titlecase_Mapping">
       Simple_Titlecase_Mapping</a>,
       <a href="http://www.unicode.org/reports/tr44/#Simple_Case_Folding">
       Simple_Case_folding</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWL">
       Changes_When_Lowercased</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWU">
       Changes_When_Uppercased</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWT">
       Changes_When_Titlecased</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWCF">
       Changes_When_Casefolded</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWCM">
       Changes_When_Casemapped</a>.</li>
<li>Normalization. All properties under that section name in
       <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">
       this table</a>.</li>
<li>Shaping and rendering.
       <a href="http://www.unicode.org/reports/tr44/#Join_Control">Join_Control</a>,
       <a href="http://www.unicode.org/reports/tr44/#Joining_Group">Joining_Group</a>,
       <a href="http://www.unicode.org/reports/tr44/#Joining_Type">Joining_Type</a>,
       <a href="http://www.unicode.org/reports/tr44/#Indic_Syllabic_Category">
       Indic_Syllabic_Category</a>
       <a href="http://www.unicode.org/reports/tr44/#Indic_Positional_Category">
       Indic_Positional_Category</a>.</li>
<li>Bidirectional. All properties under that section name in
       <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">
       this table</a>.</li>
<li>CJK.
      <a href="http://www.unicode.org/reports/tr44/#Unicode_Radical_Stroke">
      Unicode_Radical_Stroke</a> and all the properties of the
      <a href="http://www.unicode.org/reports/tr38/">Unicode HAN Database</a>.</li>
<li>Miscellaneous.
       <a href="http://www.unicode.org/reports/tr44/#STerm">STerm</a></li>
<li>Contributory properties. All properties under that section in
       <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">this
       table.</a></li>
</ul>
<br>
<br>
<h1 id="distrib_omit">Property module distribution and omissions</h1>
<p>

    Properties are approximatively distributed in modules by scope of use
    like in this
    <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">property
    index table</a>. However some subset of properties
    live in their own modules.
<p>

    Obsolete and
    <a href="http://www.unicode.org/reports/tr44/#Deprecated_Property_Table">
    deprecated</a> properties are
    omitted.  So are those related to normalization, shaping and
    bidirectionality. Here is the full list of omitted properties,
    if you think one of these property should be added get in touch
    with a rationale.
    <ul>
<li>General properties.
       <a href="http://www.unicode.org/reports/tr44/#Hangul_Syllable_Type">
       Hangul_Syllable_Type</a>.</li>
<li>Case.
       <a href="http://www.unicode.org/reports/tr44/#Simple_Lowercase_Mapping">
       Simple_Lowercase_Mapping</a>,
       <a href="http://www.unicode.org/reports/tr44/#Simple_Uppercase_Mapping">
       Simple_Uppercase_Mapping</a>,
       <a href="http://www.unicode.org/reports/tr44/#Simple_Titlecase_Mapping">
       Simple_Titlecase_Mapping</a>,
       <a href="http://www.unicode.org/reports/tr44/#Simple_Case_Folding">
       Simple_Case_folding</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWL">
       Changes_When_Lowercased</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWU">
       Changes_When_Uppercased</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWT">
       Changes_When_Titlecased</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWCF">
       Changes_When_Casefolded</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWCM">
       Changes_When_Casemapped</a>.</li>
<li>Normalization. All properties under that section name in
       <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">
       this table</a>.</li>
<li>Shaping and rendering.
       <a href="http://www.unicode.org/reports/tr44/#Join_Control">Join_Control</a>,
       <a href="http://www.unicode.org/reports/tr44/#Joining_Group">Joining_Group</a>,
       <a href="http://www.unicode.org/reports/tr44/#Joining_Type">Joining_Type</a>,
       <a href="http://www.unicode.org/reports/tr44/#Indic_Syllabic_Category">
       Indic_Syllabic_Category</a>
       <a href="http://www.unicode.org/reports/tr44/#Indic_Positional_Category">
       Indic_Positional_Category</a>.</li>
<li>Bidirectional. All properties under that section name in
       <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">
       this table</a>.</li>
<li>CJK.
      <a href="http://www.unicode.org/reports/tr44/#Unicode_Radical_Stroke">
      Unicode_Radical_Stroke</a> and all the properties of the
      <a href="http://www.unicode.org/reports/tr38/">Unicode HAN Database</a>.</li>
<li>Miscellaneous.
       <a href="http://www.unicode.org/reports/tr44/#STerm">STerm</a></li>
<li>Contributory properties. All properties under that section in
       <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">this
       table.</a></li>
</ul>
<br>
<br>
<h1 id="uminimal">Minimal Unicode introduction</h1>
<p>

    <h2 id="characters">Characters — if they exist</h2>
<p>

    The purpose of Unicode is to have a universal way of representing
    characters of writing systems known to the world in computer
    systems. Defining the notion of character is a very complicated
    question with both philosophical and political implications. To
    side step these issues, we only talk about characters from a
    programmer's point of view and simply say that the purpose of
    Unicode is to assign meaning to the integers of a well-defined
    integer range.
<p>

    This range is called the Unicode <em>codespace</em>, it spans from
    <code class="code">0x0000</code> to <code class="code">0x10FFFF</code> and its boundaries are cast in
    stone. Members of this range are called Unicode <em>code points</em>.
    Note that an OCaml <code class="code">int</code> value can represent them on both 32- and
    64-bit platforms.
<p>

    There's a lot of (non-exclusive)
    <a href="http://www.unicode.org/glossary/">terminology</a> predicates that
    can be applied to code points. I will only mention the most useful
    ones here.
<p>

    First there are the <em>reserved</em> or <em>unassigned</em> code points,
    those are the integers to which the standard doesn't assign any
    meaning <em>yet</em>. They are reserved for future assignment and may
    become meaningful in newer versions of the standard. Be aware that
    once a code point has been assigned (aka as <em>encoded</em>) by the
    standard most of its properties may never change again, see the
    <a href="http://www.unicode.org/policies/stability_policy.html">stability
    policy</a> for details.
<p>

    A very important subset of code points are the Unicode <em>scalar
    values</em>, these are the code points that belong to the ranges
    <code class="code">0x0000</code>…<code class="code">0xD7FF</code> and <code class="code">0xE000</code>…<code class="code">0x10FFFF</code>. This is the
    complete Unicode codespace minus the range <code class="code">0xD800</code>…<code class="code">0xDFFF</code>
    of so called <em>surrogate</em> code points, a hack to be able to
    encode all scalar values in UTF-16 (more on that below).
<p>

    Scalar values are what I call, by a <b>total abuse of
    terminology</b>, the Unicode characters; it is what a proper <code class="code">uchar</code>
    type should represent. From a programmer's point of view they are
    the sole integers you will have to deal with during processing and
    the only code points that you are allowed to serialize and
    deserialize to valid Unicode byte sequences.
<p>

    Unicode uses a standard notation to denote code points in running
    text. A code point is expressed as U+n where <em>n</em> is four to six
    uppercase hexadecimal digits with leading zeros omitted unless the
    code point has fewer than four digits (in <code class="code">printf</code> words
    <code class="code"><span class="string">"U+%04X"</span></code>).  For example the code point bounds are expressed by
    U+0000 and U+10FFFF and the surrogate bounds by U+D800 and U+DFFF.
<p>

    <h2 id="assignements">Interlude — what is assigned ?</h2>
<p>

    Lots of the world's scripts are encoded in the standard. The
    <a href="http://www.unicode.org/charts/">code charts</a> give a precise idea
    of the coverage.
<p>

    In order to be sucessful Unicode decided to be inclusive and to
    contain pre-existing international and national standards. For
    example the scalar values from U+0000 to U+007F correspond exactly
    to the code values of characters encoded by the US-ASCII standard,
    while those from U+0000 to U+00FF correspond exactly to the code
    values of ISO-8859-1 (latin1). Many other standard are injected
    into the codespace but their map to Unicode scalar values may not be
    as straightforward as the two examples given above.
<p>

    One thing to be aware of is that because of the inclusive nature
    of the standard the same abstract character may be represented in
    more than one way by the standard. A simple example is the latin
    character "é", which can either be represented by the single
    scalar value U+00E9 or by the <em>sequence</em> of scalar values
    &lt;U+0065, U+0301&gt; that is a latin small letter "e" followed by the
    combining acute accent "´". This non uniqueness of representation
    is problematic, for example whenever you want to test sequences of
    scalar values for equality. Unicode solves this by defining
    equivalence classes between sequences of scalar values, this is
    called Unicode normalization and we will talk about it later.
<p>

    Another issue is character spoofing. Many encoded characters
    ressemble each other when displayed but have different scalar
    values and meaning. The
    <a href="http://www.unicode.org/faq/security.html">Unicode Security FAQ</a>
    has more information and pointers about these issues.
<p>

    <h2 id="serializing">Serializing integers — UTF-X</h2>
<p>

    There is more than one way of representing a large integer as a
    sequence of bytes. The Unicode standard defines seven <em>encoding
    schemes</em>, also known as Unicode transformation formats (UTF), that
    precisely define how to encode and decode <em>scalar values</em> — take
    note, scalar values, <b>not code points</b> — as byte sequences.
<p>

    <ul>
<li>UTF-8, a scalar value is represented by a sequence of one
       to 4 bytes. One of the valuable property of UTF-8 is that
       it is compatible with the encoding of US-ASCII: the one byte
       sequences are solely used for encoding the 128 scalar
       value U+0000 to U+007F which correspond exactly to the US-ASCII code
       values. Any scalar value stricly greater than U+007F will use more than
       one byte.</li>
<li>UTF-16BE, a scalar value is either represented by one
       16 bit big-endian integer if its scalar value fits or by
       two surrogate code points encoded as 16 bit big-endian integers (how
       exactly is beyond the scope of this introduction).</li>
<li>UTF-16LE is like UTF-16BE but uses little-endian encoded integers.</li>
<li>UTF-16 is either UTF-16BE or UTF-16LE. The endianness is
       determined by looking at the two initial bytes of the data
       stream:
       <OL>
<li>If they encode a byte order mark character (BOM,
       U+FEFF) they will be either <code class="code">(0xFF,0xFE)</code>, indicating
       UTF-16LE, or <code class="code">(0xFE,0xFF)</code> indicating UTF-16BE.</li>
<li>Otherwise UTF-16BE is assumed.</li>
</OL>
</li>
<li>UTF-32BE, a scalar value is represented by one 32 bit big-endian
       integer.</li>
<li>UTF-32LE is like UTF-32BE but uses little-endian encoded integers.</li>
<li>UTF-32 is either UTF-32BE or UTF-32LE, using the same
       byte order mark mechanism as UTF-16, looking at the four initial
       bytes of the data stream.</li>
</ul>

<p>

    The cost of using one representation over the other depends on the
    character usage. For example UTF-8 is fine for latin scripts but
    wasteful for east-asian scripts, while the converse is true for UTF-16.
    I never saw any usage of UTF-32 on disk or wires, it is very wasteful.
    However, in memory, UTF-32 has the advantage that characters become
    directly indexable.
<p>

    For more information see the
    <a href="http://www.unicode.org/faq/utf_bom.html">Unicode UTF-8, UTF-16,
    UTF-32 and BOM FAQ</a>.
<p>

    <h2 id="2_InterludeUsefulscalarvalues">Interlude — Useful scalar values</h2>
<p>

    The following scalar values are useful to know:
    <ul>
<li>U+FEFF, the byte order mark (BOM) character used to
     detect endiannes on byte order sensitive UTFs.</li>
<li>U+FFFD, the replacement character. Can be used to: stand
      for unrepresentable characters when transcoding from
      another representation, indicate that something
      was lost in best-effort UTF decoders, etc.</li>
<li>U+1F42B, the emoji bactrian camel (🐫, since Unicode 6.0.0).</li>
</ul>

<p>

    <h2 id="equivalence">Equivalence and normalization</h2>
<p>

    We mentioned above that concrete textual data may be represented by
    more than one sequence of scalar values. Latin letters with
    diacritics are a simple example of that. In order to be able to
    test two sequences of scalar values for equality we should be able
    to ignore these differences. The easiest way to do so is to convert
    them to a normal form where these differences are removed and then
    use binary equality to test them.
<p>

    However first we need to define a notion of equality between
    sequences. Unicode defines two of them, which one to use depends
    on your processing context.
    <ul>
<li><em>Canonical</em> equivalence. Equivalent
       sequences should display and and be interpreted the
       same way when printed. For example the sequence
       "B", "Ä" (&lt;U+0042, U+00C4&gt;) is
       canonically equivalent to "B", "A", "¨" (&lt;U+0042, U+0041, U+0308&gt;).</li>
<li><em>Compatibility</em> equivalence. Equivalent sequences
       may have format differences in display and may be interpreted
       differently in some contexts. For example the sequence made
       of the latin small ligature fi "ﬁ" (&lt;U+FB01&gt;) is compatibility
       equivalent to the sequence "f", "i" (&lt;U+0066, U+0069&gt;). These
       two sequences are however not canonically equivalent.</li>
</ul>

<p>

    Canonical equivalence is included in compatiblity equivalence: two
    canonically equivalent sequences are also compatibility
    equivalent, but the converse may not be true.
<p>

    A normal form is a function mapping a sequence of scalar values to
    a sequence of scalar values. The Unicode standard defines four
    different normal forms, the one to use depends on the equivalence
    you want and your processing context:
    <ul>
<li>Normalization form D (NFD). Removes any canonical difference
       and decomposes characters. For example the sequence "é"
       (&lt;U+00E9&gt;) will normalize to the sequence "e", "´" (&lt;U+0065,
       U+0301&gt;.)</li>
<li>Normalization form C (NFC). Removes any canonical difference
       and composes characters. For example the sequence "e", "´"
       (&lt;U+0065, U+0301&gt;) will normalize to the sequence "é"
       (&lt;U+00E9&gt;)</li>
<li>Normalization form KD (NFKD). Removes canonical and compatibility
       differences and decomposes characters.</li>
<li>Normalization form KC (NFKC). Removes canonical and compatibility
       differences and composes characters.</li>
</ul>

<p>

    Once you have two sequences in a known normal form you can compare
    them using binary equality. If the normal form is NFD or NFC,
    binary equality will entail canonical equivalence of the
    sequences. If the normal form is NFKC or NFKD equality will entail
    compatibility equivalence of the sequences. Note that normal forms
    are <b>not</b> closed under concatenation: if you concatenate two
    sequence of scalar values you have to renormalize the result.
<p>

    For more information about normalization, see the
    <a href="http://www.unicode.org/faq/normalization.html">Normalization FAQ</a>.
<p>

    <h2 id="collation">Collation — sorting in alphabetical order</h2>
<p>

    Normalisation forms allow to define a total order between
    sequences of scalar values using binary comparison. However this
    order is purely arbitrary. It has no meaning because the magnitude
    of a scalar value has, in general, no meaning. The process of
    ordering sequences of scalar values in a standard order like
    alphabetical order is called <em>collation</em>. Unicode defines a
    customizable algorithm to order two sequences of scalar values in
    a meaningful way, the Unicode collation algorithm. For more
    information and further pointers see the
    <a href="http://www.unicode.org/faq/collation.html">Unicode Collation
    FAQ</a>.
<p>

    <h2 id="tips">Biased tips for OCaml programs and libraries</h2>
<p>

    <b>Character data as UTF-8 encoded OCaml strings.</b> For most OCaml
    programs it will be entirely sufficient to deal with Unicode by
    just treating the byte sequence of regular OCaml <code class="code">string</code>s as <b>    valid</b> UTF-8 encoded data.
<p>

    Many libraries will already return you character data under this
    representation. Besides latin1 identifiers having been deprecated
    in OCaml 4.01, UTF-8 encoding your sources allows you to write
    UTF-8 encoded string literals directly in your programs. Be aware
    though that as far as OCaml's compiler is concerned these are just
    sequences of bytes and you can't trust these strings to be valid
    UTF-8 as they depend on how correctly your editor encodes them.
    That is unless you escape their valid UTF-8 bytes explicitely (e.g.
    <code class="code"><span class="string">"\xF0\x9F\x90\xAB"</span></code> is the correct encoding of U+1F42B), you <b>will
    need</b> to validate them and most likely normalize them.
<p>

    Checking the validity of UTF-8 strings should only be performed at
    the boundaries of your program: on your string literals, on data
    input or on the results of untrusted libraries (be careful, some
    libraries like Yojson will happily return you invalid UTF-8
    strings). This allows you to only deal with valid UTF-8 throughout
    your program and avoid redundant validity checks, internally or on
    output. The following properties of UTF-8 are useful to remember:
    <ul>
<li>UTF-8 validity is closed under string concatenation:
       concatenating two valid UTF-8 strings results in a valid UTF-8
       string.</li>
<li>Splitting a valid UTF-8 encoded string at UTF-8
       encoded US-ASCII scalar values (i.e. at any byte &lt; 128) will
       result in valid UTF-8 encoded substrings.</li>
</ul>

    For checking validity or recode the other UTF encoding schemes
    into UTF-8 encoded OCaml <code class="code">strings</code>, the <code class="code"><span class="constructor">Uutf</span></code> module can be
    used. It will also be useful if you need to fold over the scalar
    values of your UTF-8 encoded strings, or build new UTF-8 strings
    from scalar values.
<p>

    <b>UTF-8 and ASCII.</b> As mentioned above, each of the 128 US-ASCII
    characters is represented by its own US-ASCII byte representation
    in UTF-8. So if you want to look for an US-ASCII character in an
    UTF-8 encoded string, you can just scan the bytes.  But beware on
    the nature of your data and the algorithm you need to
    implement. For example to detect spaces in the string, looking for
    the US-ASCII space U+0020 may not be sufficient, there are a lot
    of other space characters like the no break space U+00A0 that are
    beyond the US-ASCII repertoire. Folding over the scalar values
    with <code class="code"><span class="constructor">Uutf</span></code> and checking them with <a href="Uucp.White.html#VALis_white_space"><code class="code"><span class="constructor">Uucp</span>.<span class="constructor">White</span>.is_white_space</code></a> is a
    better idea. Same holds for line breaks, see for example
    <code class="code"><span class="constructor">Uutf</span>.nln</code> and <code class="code"><span class="constructor">Uutf</span>.readlines</code> for more information about these
    issues.
<p>

    <b>Equating and comparing UTF-8 encoded OCaml strings.</b>  If you
    understood well the above section about <a href="Uucp.html#equivalence">equivalence
    and normalization</a> you should realise that blindly comparing UTF-8
    encoded OCaml strings using <code class="code"><span class="constructor">Pervasives</span>.compare</code> won't bring you
    anywhere if you don't normalize them before. The <code class="code"><span class="constructor">Uunf</span></code> module
    can be used for that. Don't forget that normalization is not
    closed under string concatenation.
<p>

    Using <code class="code"><span class="constructor">Pervasives</span>.compare</code> on <em>normalized</em> UTF-8 encoded OCaml
    strings defines a total order on them that you can use with the
    <code class="code"><span class="constructor">Map</span></code> or <code class="code"><span class="constructor">Set</span></code> modules as long as you are not interested in the actual
    <em>meaning</em> of the order.
<p>

    If you are looking for case insensitive equality have a look at
    the <a href="Uucp.Case.html#caselesseq">sample code</a> of the <a href="Uucp.Case.html"><code class="code"><span class="constructor">Uucp</span>.<span class="constructor">Case</span></code></a> module.
<p>

    <b>Sort strings alphabetically.</b>
    The only solution at the moment for collating strings is to use
    <a href="https://github.com/yoriyuki/Camomile">Camomile</a> but be aware
    that it supports only Unicode 3.2 character data so don't be
    surprised if newer scripts don't order correctly.  The official
    collation data also has been significantly tweaked since then.
<p>

    <b>Range processing.</b> Forget about trying to process Unicode
    characters using hard coded ranges of scalar values like it was
    possible to do with US-ASCII. The Unicode standard is not closed,
    it is evolving, new characters are being assigned. This makes it
    impossible to derive properties based simply on their integer value
    or position in ranges of characters. That's the reason why we
    have the Unicode character database and <code class="code"><span class="constructor">Uucp</span></code> to access their
    properties. Using <a href="Uucp.White.html#VALis_white_space"><code class="code"><span class="constructor">Uucp</span>.<span class="constructor">White</span>.is_white_space</code></a> will be future proof should
    a new character deemed white be added to the standard (both <code class="code"><span class="constructor">Uucp</span></code>
    and your progam will need a recompile though).
<p>

    <b>Transcoding.</b> Transcoding from legacy encodings to
    Unicode may be quite involved, use
    <a href="https://github.com/yoriyuki/Camomile">Camomile</a> if you need to do
    that.  There is however one translation that is very easy and
    direct: it is the one from ISO 8859-1 also known as latin1,
    the default encoding of OCaml <code class="code">char</code>s. latin1 having been encoded in
    Unicode in the range of scalar values U+0000 to U+00FF which corresponds
    to latin1 code value, the translation is trivial, it is the identity:
<pre class="codepre"><code class="code"><span class="keyword">let</span>&nbsp;char_to_scalar_value&nbsp;c&nbsp;=&nbsp;<span class="constructor">Char</span>.code&nbsp;c<br>
<span class="keyword">let</span>&nbsp;char_of_scalar_value&nbsp;s&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;&gt;&nbsp;255&nbsp;<span class="keyword">then</span>&nbsp;invalid_arg&nbsp;<span class="string">""</span>&nbsp;<span class="comment">(*&nbsp;can't&nbsp;represent&nbsp;*)</span>&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Char</span>.chr&nbsp;s<br>
</code></pre>
<p>

    <b>Pretty-printing code points in ASCII</b> <code class="code"><span class="string">"U+%04X"</span></code> is an OCaml
    formatting string for printing an US-ASCII representation of an
    Unicode code point according to the standards' notational
    conventions.
<p>

    <b>OCaml libraries.</b> If you write a library that deals with
    textual data, you should, unless technically impossible, always
    interact with the client of the library using Unicode. If there
    are other encodings involved transcode them to/from Unicode so
    that the client needs only to deal with Unicode, the burden of
    dealing with the encoding mess has to be on the library, not the client.
<p>

    In this case there is no absolute need to depend on an Unicode text
    data structure, just use <b>valid</b> UTF-8 encoded data as OCaml
    <code class="code">string</code>s. Specify clearly in the documentation that all the
    <code class="code">string</code>s returned by or given to the library must be valid
    UTF-8 encoded data. The validity contract is important for
    performance reasons, it allows the client to trust the string and
    avoid performing redundant checks and the library to trust the
    strings it was given without having to perform further
    checks. Remember that concatenating to UTF-8 valid strings results
    in an UTF-8 valid string.<br>
<br>
<h1 id="distrib_omit">Property module distribution and omissions</h1>
<p>

    Properties are approximatively distributed in modules by scope of use
    like in this
    <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">property
    index table</a>. However some subset of properties
    live in their own modules.
<p>

    Obsolete and
    <a href="http://www.unicode.org/reports/tr44/#Deprecated_Property_Table">
    deprecated</a> properties are
    omitted.  So are those related to normalization, shaping and
    bidirectionality. Here is the full list of omitted properties,
    if you think one of these property should be added get in touch
    with a rationale.
    <ul>
<li>General properties.
       <a href="http://www.unicode.org/reports/tr44/#Hangul_Syllable_Type">
       Hangul_Syllable_Type</a>.</li>
<li>Case.
       <a href="http://www.unicode.org/reports/tr44/#Simple_Lowercase_Mapping">
       Simple_Lowercase_Mapping</a>,
       <a href="http://www.unicode.org/reports/tr44/#Simple_Uppercase_Mapping">
       Simple_Uppercase_Mapping</a>,
       <a href="http://www.unicode.org/reports/tr44/#Simple_Titlecase_Mapping">
       Simple_Titlecase_Mapping</a>,
       <a href="http://www.unicode.org/reports/tr44/#Simple_Case_Folding">
       Simple_Case_folding</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWL">
       Changes_When_Lowercased</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWU">
       Changes_When_Uppercased</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWT">
       Changes_When_Titlecased</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWCF">
       Changes_When_Casefolded</a>,
       <a href="http://www.unicode.org/reports/tr44/#CWCM">
       Changes_When_Casemapped</a>.</li>
<li>Normalization. All properties under that section name in
       <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">
       this table</a>.</li>
<li>Shaping and rendering.
       <a href="http://www.unicode.org/reports/tr44/#Join_Control">Join_Control</a>,
       <a href="http://www.unicode.org/reports/tr44/#Joining_Group">Joining_Group</a>,
       <a href="http://www.unicode.org/reports/tr44/#Joining_Type">Joining_Type</a>,
       <a href="http://www.unicode.org/reports/tr44/#Indic_Syllabic_Category">
       Indic_Syllabic_Category</a>
       <a href="http://www.unicode.org/reports/tr44/#Indic_Positional_Category">
       Indic_Positional_Category</a>.</li>
<li>Bidirectional. All properties under that section name in
       <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">
       this table</a>.</li>
<li>CJK.
      <a href="http://www.unicode.org/reports/tr44/#Unicode_Radical_Stroke">
      Unicode_Radical_Stroke</a> and all the properties of the
      <a href="http://www.unicode.org/reports/tr38/">Unicode HAN Database</a>.</li>
<li>Miscellaneous.
       <a href="http://www.unicode.org/reports/tr44/#STerm">STerm</a></li>
<li>Contributory properties. All properties under that section in
       <a href="http://www.unicode.org/reports/tr44/#Property_Index_Table">this
       table.</a></li>
</ul>
<br>
<br>
<h1 id="uminimal">Minimal Unicode introduction</h1>
<p>

    <h2 id="characters">Characters — if they exist</h2>
<p>

    The purpose of Unicode is to have a universal way of representing
    characters of writing systems known to the world in computer
    systems. Defining the notion of character is a very complicated
    question with both philosophical and political implications. To
    side step these issues, we only talk about characters from a
    programmer's point of view and simply say that the purpose of
    Unicode is to assign meaning to the integers of a well-defined
    integer range.
<p>

    This range is called the Unicode <em>codespace</em>, it spans from
    <code class="code">0x0000</code> to <code class="code">0x10FFFF</code> and its boundaries are cast in
    stone. Members of this range are called Unicode <em>code points</em>.
    Note that an OCaml <code class="code">int</code> value can represent them on both 32- and
    64-bit platforms.
<p>

    There's a lot of (non-exclusive)
    <a href="http://www.unicode.org/glossary/">terminology</a> predicates that
    can be applied to code points. I will only mention the most useful
    ones here.
<p>

    First there are the <em>reserved</em> or <em>unassigned</em> code points,
    those are the integers to which the standard doesn't assign any
    meaning <em>yet</em>. They are reserved for future assignment and may
    become meaningful in newer versions of the standard. Be aware that
    once a code point has been assigned (aka as <em>encoded</em>) by the
    standard most of its properties may never change again, see the
    <a href="http://www.unicode.org/policies/stability_policy.html">stability
    policy</a> for details.
<p>

    A very important subset of code points are the Unicode <em>scalar
    values</em>, these are the code points that belong to the ranges
    <code class="code">0x0000</code>…<code class="code">0xD7FF</code> and <code class="code">0xE000</code>…<code class="code">0x10FFFF</code>. This is the
    complete Unicode codespace minus the range <code class="code">0xD800</code>…<code class="code">0xDFFF</code>
    of so called <em>surrogate</em> code points, a hack to be able to
    encode all scalar values in UTF-16 (more on that below).
<p>

    Scalar values are what I call, by a <b>total abuse of
    terminology</b>, the Unicode characters; it is what a proper <code class="code">uchar</code>
    type should represent. From a programmer's point of view they are
    the sole integers you will have to deal with during processing and
    the only code points that you are allowed to serialize and
    deserialize to valid Unicode byte sequences.
<p>

    Unicode uses a standard notation to denote code points in running
    text. A code point is expressed as U+n where <em>n</em> is four to six
    uppercase hexadecimal digits with leading zeros omitted unless the
    code point has fewer than four digits (in <code class="code">printf</code> words
    <code class="code"><span class="string">"U+%04X"</span></code>).  For example the code point bounds are expressed by
    U+0000 and U+10FFFF and the surrogate bounds by U+D800 and U+DFFF.
<p>

    <h2 id="assignements">Interlude — what is assigned ?</h2>
<p>

    Lots of the world's scripts are encoded in the standard. The
    <a href="http://www.unicode.org/charts/">code charts</a> give a precise idea
    of the coverage.
<p>

    In order to be sucessful Unicode decided to be inclusive and to
    contain pre-existing international and national standards. For
    example the scalar values from U+0000 to U+007F correspond exactly
    to the code values of characters encoded by the US-ASCII standard,
    while those from U+0000 to U+00FF correspond exactly to the code
    values of ISO-8859-1 (latin1). Many other standard are injected
    into the codespace but their map to Unicode scalar values may not be
    as straightforward as the two examples given above.
<p>

    One thing to be aware of is that because of the inclusive nature
    of the standard the same abstract character may be represented in
    more than one way by the standard. A simple example is the latin
    character "é", which can either be represented by the single
    scalar value U+00E9 or by the <em>sequence</em> of scalar values
    &lt;U+0065, U+0301&gt; that is a latin small letter "e" followed by the
    combining acute accent "´". This non uniqueness of representation
    is problematic, for example whenever you want to test sequences of
    scalar values for equality. Unicode solves this by defining
    equivalence classes between sequences of scalar values, this is
    called Unicode normalization and we will talk about it later.
<p>

    Another issue is character spoofing. Many encoded characters
    ressemble each other when displayed but have different scalar
    values and meaning. The
    <a href="http://www.unicode.org/faq/security.html">Unicode Security FAQ</a>
    has more information and pointers about these issues.
<p>

    <h2 id="serializing">Serializing integers — UTF-X</h2>
<p>

    There is more than one way of representing a large integer as a
    sequence of bytes. The Unicode standard defines seven <em>encoding
    schemes</em>, also known as Unicode transformation formats (UTF), that
    precisely define how to encode and decode <em>scalar values</em> — take
    note, scalar values, <b>not code points</b> — as byte sequences.
<p>

    <ul>
<li>UTF-8, a scalar value is represented by a sequence of one
       to 4 bytes. One of the valuable property of UTF-8 is that
       it is compatible with the encoding of US-ASCII: the one byte
       sequences are solely used for encoding the 128 scalar
       value U+0000 to U+007F which correspond exactly to the US-ASCII code
       values. Any scalar value stricly greater than U+007F will use more than
       one byte.</li>
<li>UTF-16BE, a scalar value is either represented by one
       16 bit big-endian integer if its scalar value fits or by
       two surrogate code points encoded as 16 bit big-endian integers (how
       exactly is beyond the scope of this introduction).</li>
<li>UTF-16LE is like UTF-16BE but uses little-endian encoded integers.</li>
<li>UTF-16 is either UTF-16BE or UTF-16LE. The endianness is
       determined by looking at the two initial bytes of the data
       stream:
       <OL>
<li>If they encode a byte order mark character (BOM,
       U+FEFF) they will be either <code class="code">(0xFF,0xFE)</code>, indicating
       UTF-16LE, or <code class="code">(0xFE,0xFF)</code> indicating UTF-16BE.</li>
<li>Otherwise UTF-16BE is assumed.</li>
</OL>
</li>
<li>UTF-32BE, a scalar value is represented by one 32 bit big-endian
       integer.</li>
<li>UTF-32LE is like UTF-32BE but uses little-endian encoded integers.</li>
<li>UTF-32 is either UTF-32BE or UTF-32LE, using the same
       byte order mark mechanism as UTF-16, looking at the four initial
       bytes of the data stream.</li>
</ul>

<p>

    The cost of using one representation over the other depends on the
    character usage. For example UTF-8 is fine for latin scripts but
    wasteful for east-asian scripts, while the converse is true for UTF-16.
    I never saw any usage of UTF-32 on disk or wires, it is very wasteful.
    However, in memory, UTF-32 has the advantage that characters become
    directly indexable.
<p>

    For more information see the
    <a href="http://www.unicode.org/faq/utf_bom.html">Unicode UTF-8, UTF-16,
    UTF-32 and BOM FAQ</a>.
<p>

    <h2 id="2_InterludeUsefulscalarvalues">Interlude — Useful scalar values</h2>
<p>

    The following scalar values are useful to know:
    <ul>
<li>U+FEFF, the byte order mark (BOM) character used to
     detect endiannes on byte order sensitive UTFs.</li>
<li>U+FFFD, the replacement character. Can be used to: stand
      for unrepresentable characters when transcoding from
      another representation, indicate that something
      was lost in best-effort UTF decoders, etc.</li>
<li>U+1F42B, the emoji bactrian camel (🐫, since Unicode 6.0.0).</li>
</ul>

<p>

    <h2 id="equivalence">Equivalence and normalization</h2>
<p>

    We mentioned above that concrete textual data may be represented by
    more than one sequence of scalar values. Latin letters with
    diacritics are a simple example of that. In order to be able to
    test two sequences of scalar values for equality we should be able
    to ignore these differences. The easiest way to do so is to convert
    them to a normal form where these differences are removed and then
    use binary equality to test them.
<p>

    However first we need to define a notion of equality between
    sequences. Unicode defines two of them, which one to use depends
    on your processing context.
    <ul>
<li><em>Canonical</em> equivalence. Equivalent
       sequences should display and and be interpreted the
       same way when printed. For example the sequence
       "B", "Ä" (&lt;U+0042, U+00C4&gt;) is
       canonically equivalent to "B", "A", "¨" (&lt;U+0042, U+0041, U+0308&gt;).</li>
<li><em>Compatibility</em> equivalence. Equivalent sequences
       may have format differences in display and may be interpreted
       differently in some contexts. For example the sequence made
       of the latin small ligature fi "ﬁ" (&lt;U+FB01&gt;) is compatibility
       equivalent to the sequence "f", "i" (&lt;U+0066, U+0069&gt;). These
       two sequences are however not canonically equivalent.</li>
</ul>

<p>

    Canonical equivalence is included in compatiblity equivalence: two
    canonically equivalent sequences are also compatibility
    equivalent, but the converse may not be true.
<p>

    A normal form is a function mapping a sequence of scalar values to
    a sequence of scalar values. The Unicode standard defines four
    different normal forms, the one to use depends on the equivalence
    you want and your processing context:
    <ul>
<li>Normalization form D (NFD). Removes any canonical difference
       and decomposes characters. For example the sequence "é"
       (&lt;U+00E9&gt;) will normalize to the sequence "e", "´" (&lt;U+0065,
       U+0301&gt;.)</li>
<li>Normalization form C (NFC). Removes any canonical difference
       and composes characters. For example the sequence "e", "´"
       (&lt;U+0065, U+0301&gt;) will normalize to the sequence "é"
       (&lt;U+00E9&gt;)</li>
<li>Normalization form KD (NFKD). Removes canonical and compatibility
       differences and decomposes characters.</li>
<li>Normalization form KC (NFKC). Removes canonical and compatibility
       differences and composes characters.</li>
</ul>

<p>

    Once you have two sequences in a known normal form you can compare
    them using binary equality. If the normal form is NFD or NFC,
    binary equality will entail canonical equivalence of the
    sequences. If the normal form is NFKC or NFKD equality will entail
    compatibility equivalence of the sequences. Note that normal forms
    are <b>not</b> closed under concatenation: if you concatenate two
    sequence of scalar values you have to renormalize the result.
<p>

    For more information about normalization, see the
    <a href="http://www.unicode.org/faq/normalization.html">Normalization FAQ</a>.
<p>

    <h2 id="collation">Collation — sorting in alphabetical order</h2>
<p>

    Normalisation forms allow to define a total order between
    sequences of scalar values using binary comparison. However this
    order is purely arbitrary. It has no meaning because the magnitude
    of a scalar value has, in general, no meaning. The process of
    ordering sequences of scalar values in a standard order like
    alphabetical order is called <em>collation</em>. Unicode defines a
    customizable algorithm to order two sequences of scalar values in
    a meaningful way, the Unicode collation algorithm. For more
    information and further pointers see the
    <a href="http://www.unicode.org/faq/collation.html">Unicode Collation
    FAQ</a>.
<p>

    <h2 id="tips">Biased tips for OCaml programs and libraries</h2>
<p>

    <b>Character data as UTF-8 encoded OCaml strings.</b> For most OCaml
    programs it will be entirely sufficient to deal with Unicode by
    just treating the byte sequence of regular OCaml <code class="code">string</code>s as <b>    valid</b> UTF-8 encoded data.
<p>

    Many libraries will already return you character data under this
    representation. Besides latin1 identifiers having been deprecated
    in OCaml 4.01, UTF-8 encoding your sources allows you to write
    UTF-8 encoded string literals directly in your programs. Be aware
    though that as far as OCaml's compiler is concerned these are just
    sequences of bytes and you can't trust these strings to be valid
    UTF-8 as they depend on how correctly your editor encodes them.
    That is unless you escape their valid UTF-8 bytes explicitely (e.g.
    <code class="code"><span class="string">"\xF0\x9F\x90\xAB"</span></code> is the correct encoding of U+1F42B), you <b>will
    need</b> to validate them and most likely normalize them.
<p>

    Checking the validity of UTF-8 strings should only be performed at
    the boundaries of your program: on your string literals, on data
    input or on the results of untrusted libraries (be careful, some
    libraries like Yojson will happily return you invalid UTF-8
    strings). This allows you to only deal with valid UTF-8 throughout
    your program and avoid redundant validity checks, internally or on
    output. The following properties of UTF-8 are useful to remember:
    <ul>
<li>UTF-8 validity is closed under string concatenation:
       concatenating two valid UTF-8 strings results in a valid UTF-8
       string.</li>
<li>Splitting a valid UTF-8 encoded string at UTF-8
       encoded US-ASCII scalar values (i.e. at any byte &lt; 128) will
       result in valid UTF-8 encoded substrings.</li>
</ul>

    For checking validity or recode the other UTF encoding schemes
    into UTF-8 encoded OCaml <code class="code">strings</code>, the <code class="code"><span class="constructor">Uutf</span></code> module can be
    used. It will also be useful if you need to fold over the scalar
    values of your UTF-8 encoded strings, or build new UTF-8 strings
    from scalar values.
<p>

    <b>UTF-8 and ASCII.</b> As mentioned above, each of the 128 US-ASCII
    characters is represented by its own US-ASCII byte representation
    in UTF-8. So if you want to look for an US-ASCII character in an
    UTF-8 encoded string, you can just scan the bytes.  But beware on
    the nature of your data and the algorithm you need to
    implement. For example to detect spaces in the string, looking for
    the US-ASCII space U+0020 may not be sufficient, there are a lot
    of other space characters like the no break space U+00A0 that are
    beyond the US-ASCII repertoire. Folding over the scalar values
    with <code class="code"><span class="constructor">Uutf</span></code> and checking them with <a href="Uucp.White.html#VALis_white_space"><code class="code"><span class="constructor">Uucp</span>.<span class="constructor">White</span>.is_white_space</code></a> is a
    better idea. Same holds for line breaks, see for example
    <code class="code"><span class="constructor">Uutf</span>.nln</code> and <code class="code"><span class="constructor">Uutf</span>.readlines</code> for more information about these
    issues.
<p>

    <b>Equating and comparing UTF-8 encoded OCaml strings.</b>  If you
    understood well the above section about <a href="Uucp.html#equivalence">equivalence
    and normalization</a> you should realise that blindly comparing UTF-8
    encoded OCaml strings using <code class="code"><span class="constructor">Pervasives</span>.compare</code> won't bring you
    anywhere if you don't normalize them before. The <code class="code"><span class="constructor">Uunf</span></code> module
    can be used for that. Don't forget that normalization is not
    closed under string concatenation.
<p>

    Using <code class="code"><span class="constructor">Pervasives</span>.compare</code> on <em>normalized</em> UTF-8 encoded OCaml
    strings defines a total order on them that you can use with the
    <code class="code"><span class="constructor">Map</span></code> or <code class="code"><span class="constructor">Set</span></code> modules as long as you are not interested in the actual
    <em>meaning</em> of the order.
<p>

    If you are looking for case insensitive equality have a look at
    the <a href="Uucp.Case.html#caselesseq">sample code</a> of the <a href="Uucp.Case.html"><code class="code"><span class="constructor">Uucp</span>.<span class="constructor">Case</span></code></a> module.
<p>

    <b>Sort strings alphabetically.</b>
    The only solution at the moment for collating strings is to use
    <a href="https://github.com/yoriyuki/Camomile">Camomile</a> but be aware
    that it supports only Unicode 3.2 character data so don't be
    surprised if newer scripts don't order correctly.  The official
    collation data also has been significantly tweaked since then.
<p>

    <b>Range processing.</b> Forget about trying to process Unicode
    characters using hard coded ranges of scalar values like it was
    possible to do with US-ASCII. The Unicode standard is not closed,
    it is evolving, new characters are being assigned. This makes it
    impossible to derive properties based simply on their integer value
    or position in ranges of characters. That's the reason why we
    have the Unicode character database and <code class="code"><span class="constructor">Uucp</span></code> to access their
    properties. Using <a href="Uucp.White.html#VALis_white_space"><code class="code"><span class="constructor">Uucp</span>.<span class="constructor">White</span>.is_white_space</code></a> will be future proof should
    a new character deemed white be added to the standard (both <code class="code"><span class="constructor">Uucp</span></code>
    and your progam will need a recompile though).
<p>

    <b>Transcoding.</b> Transcoding from legacy encodings to
    Unicode may be quite involved, use
    <a href="https://github.com/yoriyuki/Camomile">Camomile</a> if you need to do
    that.  There is however one translation that is very easy and
    direct: it is the one from ISO 8859-1 also known as latin1,
    the default encoding of OCaml <code class="code">char</code>s. latin1 having been encoded in
    Unicode in the range of scalar values U+0000 to U+00FF which corresponds
    to latin1 code value, the translation is trivial, it is the identity:
<pre class="codepre"><code class="code"><span class="keyword">let</span>&nbsp;char_to_scalar_value&nbsp;c&nbsp;=&nbsp;<span class="constructor">Char</span>.code&nbsp;c<br>
<span class="keyword">let</span>&nbsp;char_of_scalar_value&nbsp;s&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;s&nbsp;&gt;&nbsp;255&nbsp;<span class="keyword">then</span>&nbsp;invalid_arg&nbsp;<span class="string">""</span>&nbsp;<span class="comment">(*&nbsp;can't&nbsp;represent&nbsp;*)</span>&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Char</span>.chr&nbsp;s<br>
</code></pre>
<p>

    <b>Pretty-printing code points in ASCII</b> <code class="code"><span class="string">"U+%04X"</span></code> is an OCaml
    formatting string for printing an US-ASCII representation of an
    Unicode code point according to the standards' notational
    conventions.
<p>

    <b>OCaml libraries.</b> If you write a library that deals with
    textual data, you should, unless technically impossible, always
    interact with the client of the library using Unicode. If there
    are other encodings involved transcode them to/from Unicode so
    that the client needs only to deal with Unicode, the burden of
    dealing with the encoding mess has to be on the library, not the client.
<p>

    In this case there is no absolute need to depend on an Unicode text
    data structure, just use <b>valid</b> UTF-8 encoded data as OCaml
    <code class="code">string</code>s. Specify clearly in the documentation that all the
    <code class="code">string</code>s returned by or given to the library must be valid
    UTF-8 encoded data. The validity contract is important for
    performance reasons, it allows the client to trust the string and
    avoid performing redundant checks and the library to trust the
    strings it was given without having to perform further
    checks. Remember that concatenating to UTF-8 valid strings results
    in an UTF-8 valid string.<br>
</body></html>